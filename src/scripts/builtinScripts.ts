/**
 * Built-in scripts for Claude Autopilot
 * These scripts are embedded in the extension and copied to workspace .autopilot folder
 */

export const BUILTIN_SCRIPTS = {
    'production-readiness.js': `#!/usr/bin/env node
/**
 * Production Readiness Check
 * Checks for TODO, FIXME, placeholders, and incomplete implementations
 * Auto-generated by Claude Autopilot
 */

const fs = require('fs');
const path = require('path');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        // Patterns that indicate incomplete or non-production code
        const patterns = [
            { pattern: /TODO/gi, message: 'TODO comment found' },
            { pattern: /FIXME/gi, message: 'FIXME comment found' },
            { pattern: /PLACEHOLDER/gi, message: 'Placeholder found' },
            { pattern: /XXX/gi, message: 'XXX marker found' },
            { pattern: /HACK/gi, message: 'HACK comment found' },
            { pattern: /temporary/gi, message: 'Temporary code found' },
            { pattern: /quick\\s+fix/gi, message: 'Quick fix found' },
            { pattern: /for\\s+now/gi, message: '"for now" comment found' },
            { pattern: /simplified/gi, message: 'Simplified implementation found' },
            { pattern: /\\.\\.\\./, message: 'Ellipsis (...) found - possible incomplete code' },
            { pattern: /<<<|>>>/, message: 'Merge conflict markers found' },
            { pattern: /not\\s+implemented/gi, message: 'Not implemented found' },
            { pattern: /throw\\s+new\\s+Error\\(['\`]not\\s+implemented/gi, message: 'Not implemented error found' },
            { pattern: /console\\.(log|debug|trace)/g, message: 'Debug console statement found' },
            { pattern: /debugger;/g, message: 'Debugger statement found' }
        ];
        
        // File extensions to check
        const extensions = ['.js', '.ts', '.jsx', '.tsx', '.go', '.cpp', '.cc', '.h', '.hpp', '.rs', '.cs', '.java', '.py', '.rb', '.php', '.swift', '.kt', '.scala', '.vue', '.svelte'];
        
        // Directories to skip
        const skipDirs = ['.git', 'node_modules', 'dist', 'build', 'out', 'target', 'bin', 'obj', '.next', '.nuxt', 'coverage', '.nyc_output', 'vendor', '.autopilot'];
        
        function scanDirectory(dir) {
            const files = fs.readdirSync(dir);
            
            for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                
                if (stat.isDirectory()) {
                    if (!skipDirs.includes(file) && !file.startsWith('.')) {
                        scanDirectory(filePath);
                    }
                } else if (stat.isFile() && extensions.includes(path.extname(file).toLowerCase())) {
                    try {
                        const content = fs.readFileSync(filePath, 'utf8');
                        const lines = content.split('\\n');
                        
                        lines.forEach((line, index) => {
                            patterns.forEach(({ pattern, message }) => {
                                const match = line.match(pattern);
                                if (match) {
                                    const relPath = path.relative(process.cwd(), filePath);
                                    errors.push(\`\${relPath}:\${index + 1} - \${message}: "\${match[0]}"\`);
                                }
                            });
                        });
                    } catch (err) {
                        // Skip files that can't be read
                        if (err.code !== 'ENOENT' && err.code !== 'EISDIR') {
                            warnings.push(\`Could not read \${filePath}: \${err.message}\`);
                        }
                    }
                }
            }
        }
        
        // Start scanning from current directory
        scanDirectory(process.cwd());
        
        // Check for common incomplete patterns in specific files
        const packageJsonPath = path.join(process.cwd(), 'package.json');
        if (fs.existsSync(packageJsonPath)) {
            try {
                const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                
                // Check for common development dependencies in production
                const devDepsInMain = ['nodemon', 'jest', 'mocha', 'chai', 'sinon', 'eslint', 'prettier'];
                if (pkg.dependencies) {
                    devDepsInMain.forEach(dep => {
                        if (pkg.dependencies[dep]) {
                            warnings.push(\`Development dependency "\${dep}" found in production dependencies\`);
                        }
                    });
                }
                
                // Check for missing important fields
                if (!pkg.description || pkg.description.trim() === '') {
                    warnings.push('package.json missing description');
                }
                if (!pkg.repository) {
                    warnings.push('package.json missing repository information');
                }
                if (!pkg.license) {
                    warnings.push('package.json missing license');
                }
            } catch (err) {
                warnings.push(\`Could not parse package.json: \${err.message}\`);
            }
        }
        
        return {
            passed: errors.length === 0,
            errors,
            warnings
        };
    } catch (error) {
        return {
            passed: false,
            errors: [\`Script execution failed: \${error.message}\`],
            warnings
        };
    }
}

// Run the check and output results
check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [\`Unexpected error: \${error.message}\`]
    }, null, 2));
    process.exit(1);
});`,

    'build-check.js': `#!/usr/bin/env node
/**
 * Build Check
 * Ensures the project can build successfully
 * Auto-generated by Claude Autopilot
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        // Detect project type and run appropriate build command
        const projectRoot = process.cwd();
        let buildExecuted = false;
        
        // Node.js / JavaScript / TypeScript
        const packageJsonPath = path.join(projectRoot, 'package.json');
        if (fs.existsSync(packageJsonPath)) {
            try {
                const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                
                // Check for build script
                if (pkg.scripts && pkg.scripts.build) {
                    try {
                        console.error('Running npm build...');
                        execSync('npm run build', { 
                            stdio: ['ignore', 'ignore', 'pipe'],
                            encoding: 'utf8'
                        });
                        buildExecuted = true;
                    } catch (error) {
                        const errorOutput = error.stderr || error.message;
                        errors.push(\`npm build failed: \${errorOutput}\`);
                        buildExecuted = true;
                    }
                } else if (pkg.scripts && pkg.scripts.compile) {
                    // Some projects use 'compile' instead of 'build'
                    try {
                        console.error('Running npm compile...');
                        execSync('npm run compile', { 
                            stdio: ['ignore', 'ignore', 'pipe'],
                            encoding: 'utf8'
                        });
                        buildExecuted = true;
                    } catch (error) {
                        const errorOutput = error.stderr || error.message;
                        errors.push(\`npm compile failed: \${errorOutput}\`);
                        buildExecuted = true;
                    }
                } else {
                    // Check if it's a TypeScript project without build script
                    if (fs.existsSync(path.join(projectRoot, 'tsconfig.json'))) {
                        try {
                            console.error('Running TypeScript compiler...');
                            execSync('npx tsc --noEmit', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            buildExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.message;
                            errors.push(\`TypeScript compilation failed: \${errorOutput}\`);
                            buildExecuted = true;
                        }
                    } else {
                        warnings.push('No build script found in package.json');
                    }
                }
            } catch (error) {
                warnings.push(\`Could not parse package.json: \${error.message}\`);
            }
        }
        
        // Go
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'go.mod'))) {
            try {
                console.error('Running go build...');
                execSync('go build ./...', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(\`Go build failed: \${errorOutput}\`);
                buildExecuted = true;
            }
        }
        
        // Rust
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'Cargo.toml'))) {
            try {
                console.error('Running cargo build...');
                execSync('cargo build', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(\`Cargo build failed: \${errorOutput}\`);
                buildExecuted = true;
            }
        }
        
        // C# / .NET
        const csprojFiles = fs.readdirSync(projectRoot).filter(f => f.endsWith('.csproj'));
        const slnFiles = fs.readdirSync(projectRoot).filter(f => f.endsWith('.sln'));
        if (!buildExecuted && (csprojFiles.length > 0 || slnFiles.length > 0)) {
            try {
                console.error('Running dotnet build...');
                execSync('dotnet build', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(\`Dotnet build failed: \${errorOutput}\`);
                buildExecuted = true;
            }
        }
        
        // Java - Maven
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'pom.xml'))) {
            try {
                console.error('Running maven compile...');
                execSync('mvn compile', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(\`Maven build failed: \${errorOutput}\`);
                buildExecuted = true;
            }
        }
        
        // Java - Gradle
        if (!buildExecuted && (fs.existsSync(path.join(projectRoot, 'build.gradle')) || 
                               fs.existsSync(path.join(projectRoot, 'build.gradle.kts')))) {
            try {
                console.error('Running gradle build...');
                const gradleWrapper = fs.existsSync(path.join(projectRoot, 'gradlew')) ? './gradlew' : 'gradle';
                execSync(\`\${gradleWrapper} build\`, { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(\`Gradle build failed: \${errorOutput}\`);
                buildExecuted = true;
            }
        }
        
        // Python - setup.py
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'setup.py'))) {
            try {
                console.error('Checking Python setup...');
                execSync('python setup.py check', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                warnings.push(\`Python setup check failed: \${errorOutput}\`);
                // Don't count as error since many Python projects don't need building
            }
        }
        
        // C/C++ with Make
        if (!buildExecuted && (fs.existsSync(path.join(projectRoot, 'Makefile')) || 
                               fs.existsSync(path.join(projectRoot, 'makefile')))) {
            try {
                console.error('Running make...');
                execSync('make', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(\`Make build failed: \${errorOutput}\`);
                buildExecuted = true;
            }
        }
        
        // C/C++ with CMake
        if (!buildExecuted && fs.existsSync(path.join(projectRoot, 'CMakeLists.txt'))) {
            try {
                console.error('Running cmake build...');
                if (!fs.existsSync('build')) {
                    execSync('cmake -B build', { stdio: 'ignore' });
                }
                execSync('cmake --build build', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                buildExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                errors.push(\`CMake build failed: \${errorOutput}\`);
                buildExecuted = true;
            }
        }
        
        if (!buildExecuted) {
            warnings.push('No recognized build system found. Supported: npm, go, cargo, dotnet, maven, gradle, make, cmake');
        }
        
        return {
            passed: errors.length === 0,
            errors,
            warnings
        };
    } catch (error) {
        return {
            passed: false,
            errors: [\`Script execution failed: \${error.message}\`],
            warnings
        };
    }
}

// Run the check and output results
check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [\`Unexpected error: \${error.message}\`]
    }, null, 2));
    process.exit(1);
});`,

    'test-check.js': `#!/usr/bin/env node
/**
 * Test Check
 * Runs all tests and ensures they pass
 * Auto-generated by Claude Autopilot
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        // Detect project type and run appropriate test command
        const projectRoot = process.cwd();
        let testsExecuted = false;
        
        // Node.js / JavaScript / TypeScript
        const packageJsonPath = path.join(projectRoot, 'package.json');
        if (fs.existsSync(packageJsonPath)) {
            try {
                const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                
                // Check for test script
                if (pkg.scripts && pkg.scripts.test) {
                    try {
                        console.error('Running npm test...');
                        const output = execSync('npm test', { 
                            encoding: 'utf8',
                            env: { ...process.env, CI: 'true' } // Force non-interactive mode
                        });
                        
                        // Check if it's the default npm test script
                        if (output.includes('Error: no test specified')) {
                            warnings.push('No actual tests configured (using default npm test script)');
                        } else {
                            testsExecuted = true;
                        }
                    } catch (error) {
                        const errorOutput = error.stdout || error.stderr || error.message;
                        
                        // Check if it's just "no tests" error
                        if (errorOutput.includes('no test specified') || 
                            errorOutput.includes('No tests found')) {
                            warnings.push('No tests found in the project');
                        } else {
                            errors.push(\`Tests failed: \${errorOutput}\`);
                        }
                        testsExecuted = true;
                    }
                } else {
                    // Look for test frameworks
                    const hasJest = pkg.devDependencies?.jest || pkg.dependencies?.jest;
                    const hasMocha = pkg.devDependencies?.mocha || pkg.dependencies?.mocha;
                    const hasVitest = pkg.devDependencies?.vitest || pkg.dependencies?.vitest;
                    
                    if (hasJest) {
                        try {
                            console.error('Running Jest tests...');
                            execSync('npx jest --passWithNoTests', { 
                                encoding: 'utf8',
                                env: { ...process.env, CI: 'true' }
                            });
                            testsExecuted = true;
                        } catch (error) {
                            errors.push(\`Jest tests failed: \${error.message}\`);
                            testsExecuted = true;
                        }
                    } else if (hasMocha) {
                        try {
                            console.error('Running Mocha tests...');
                            execSync('npx mocha', { encoding: 'utf8' });
                            testsExecuted = true;
                        } catch (error) {
                            if (error.message.includes('No test files found')) {
                                warnings.push('No test files found for Mocha');
                            } else {
                                errors.push(\`Mocha tests failed: \${error.message}\`);
                            }
                            testsExecuted = true;
                        }
                    } else if (hasVitest) {
                        try {
                            console.error('Running Vitest tests...');
                            execSync('npx vitest run', { encoding: 'utf8' });
                            testsExecuted = true;
                        } catch (error) {
                            errors.push(\`Vitest tests failed: \${error.message}\`);
                            testsExecuted = true;
                        }
                    } else {
                        warnings.push('No test script or test framework found in package.json');
                    }
                }
            } catch (error) {
                warnings.push(\`Could not parse package.json: \${error.message}\`);
            }
        }
        
        // Go
        if (!testsExecuted && fs.existsSync(path.join(projectRoot, 'go.mod'))) {
            try {
                console.error('Running go test...');
                const output = execSync('go test ./...', { encoding: 'utf8' });
                
                if (output.includes('no test files')) {
                    warnings.push('No test files found in Go project');
                } else {
                    testsExecuted = true;
                }
            } catch (error) {
                const errorOutput = error.stdout || error.stderr || error.message;
                if (errorOutput.includes('no test files')) {
                    warnings.push('No test files found in Go project');
                } else {
                    errors.push(\`Go tests failed: \${errorOutput}\`);
                }
                testsExecuted = true;
            }
        }
        
        // Rust
        if (!testsExecuted && fs.existsSync(path.join(projectRoot, 'Cargo.toml'))) {
            try {
                console.error('Running cargo test...');
                execSync('cargo test', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(\`Cargo tests failed: \${error.message}\`);
                testsExecuted = true;
            }
        }
        
        // C# / .NET
        const csprojFiles = fs.readdirSync(projectRoot).filter(f => f.endsWith('.csproj') || f.endsWith('.fsproj'));
        if (!testsExecuted && csprojFiles.length > 0) {
            try {
                console.error('Running dotnet test...');
                const output = execSync('dotnet test', { encoding: 'utf8' });
                
                if (output.includes('No test is available')) {
                    warnings.push('No tests found in .NET project');
                } else {
                    testsExecuted = true;
                }
            } catch (error) {
                errors.push(\`Dotnet tests failed: \${error.message}\`);
                testsExecuted = true;
            }
        }
        
        // Java - Maven
        if (!testsExecuted && fs.existsSync(path.join(projectRoot, 'pom.xml'))) {
            try {
                console.error('Running maven test...');
                execSync('mvn test', { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                const errorOutput = error.stdout || error.stderr || error.message;
                if (errorOutput.includes('No tests to run')) {
                    warnings.push('No tests found in Maven project');
                } else {
                    errors.push(\`Maven tests failed: \${errorOutput}\`);
                }
                testsExecuted = true;
            }
        }
        
        // Java - Gradle
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, 'build.gradle')) || 
                               fs.existsSync(path.join(projectRoot, 'build.gradle.kts')))) {
            try {
                console.error('Running gradle test...');
                const gradleWrapper = fs.existsSync(path.join(projectRoot, 'gradlew')) ? './gradlew' : 'gradle';
                execSync(\`\${gradleWrapper} test\`, { encoding: 'utf8' });
                testsExecuted = true;
            } catch (error) {
                errors.push(\`Gradle tests failed: \${error.message}\`);
                testsExecuted = true;
            }
        }
        
        // Python - pytest
        if (!testsExecuted && fs.existsSync(path.join(projectRoot, 'setup.py')) || 
            fs.existsSync(path.join(projectRoot, 'pyproject.toml')) ||
            fs.existsSync(path.join(projectRoot, 'requirements.txt'))) {
            
            // Check for test directories
            const testDirs = ['tests', 'test', 'tests.py', 'test.py'];
            const hasTests = testDirs.some(dir => fs.existsSync(path.join(projectRoot, dir)));
            
            if (hasTests) {
                try {
                    console.error('Running pytest...');
                    execSync('python -m pytest', { encoding: 'utf8' });
                    testsExecuted = true;
                } catch (error) {
                    // Try with pytest directly
                    try {
                        execSync('pytest', { encoding: 'utf8' });
                        testsExecuted = true;
                    } catch (error2) {
                        // Try unittest
                        try {
                            console.error('Running unittest...');
                            execSync('python -m unittest discover', { encoding: 'utf8' });
                            testsExecuted = true;
                        } catch (error3) {
                            warnings.push('Python project found but no test runner available (pytest/unittest)');
                        }
                    }
                }
            } else {
                warnings.push('Python project found but no test directory detected');
            }
        }
        
        // Ruby - RSpec/Minitest
        if (!testsExecuted && (fs.existsSync(path.join(projectRoot, 'Gemfile')) || 
                               fs.existsSync(path.join(projectRoot, '.ruby-version')))) {
            const hasSpec = fs.existsSync(path.join(projectRoot, 'spec'));
            const hasTest = fs.existsSync(path.join(projectRoot, 'test'));
            
            if (hasSpec) {
                try {
                    console.error('Running rspec...');
                    execSync('bundle exec rspec', { encoding: 'utf8' });
                    testsExecuted = true;
                } catch (error) {
                    errors.push(\`RSpec tests failed: \${error.message}\`);
                    testsExecuted = true;
                }
            } else if (hasTest) {
                try {
                    console.error('Running rake test...');
                    execSync('bundle exec rake test', { encoding: 'utf8' });
                    testsExecuted = true;
                } catch (error) {
                    warnings.push('Ruby test directory found but tests failed to run');
                }
            } else {
                warnings.push('Ruby project found but no test directory detected');
            }
        }
        
        if (!testsExecuted) {
            warnings.push('No recognized test framework found. Supported: npm test, jest, mocha, vitest, go test, cargo test, dotnet test, maven test, gradle test, pytest, unittest, rspec, rake test');
        }
        
        // Check for test files even if no runner was found
        if (!testsExecuted) {
            const testPatterns = ['*.test.js', '*.spec.js', '*.test.ts', '*.spec.ts', '*_test.go', '*_test.py', 'test_*.py', '*Test.java', '*Tests.cs'];
            let hasTestFiles = false;
            
            function findTestFiles(dir) {
                try {
                    const files = fs.readdirSync(dir);
                    for (const file of files) {
                        const filePath = path.join(dir, file);
                        const stat = fs.statSync(filePath);
                        
                        if (stat.isDirectory() && !file.startsWith('.') && !['node_modules', 'vendor', 'target', 'build', 'dist'].includes(file)) {
                            findTestFiles(filePath);
                        } else if (stat.isFile()) {
                            for (const pattern of testPatterns) {
                                const regex = new RegExp(pattern.replace('*', '.*'));
                                if (regex.test(file)) {
                                    hasTestFiles = true;
                                    return;
                                }
                            }
                        }
                    }
                } catch (error) {
                    // Ignore permission errors
                }
            }
            
            findTestFiles(projectRoot);
            
            if (hasTestFiles) {
                warnings.push('Test files found but no test runner configured');
            }
        }
        
        return {
            passed: errors.length === 0,
            errors,
            warnings
        };
    } catch (error) {
        return {
            passed: false,
            errors: [\`Script execution failed: \${error.message}\`],
            warnings
        };
    }
}

// Run the check and output results
check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [\`Unexpected error: \${error.message}\`]
    }, null, 2));
    process.exit(1);
});`,

    'format-check.js': `#!/usr/bin/env node
/**
 * Format Check
 * Ensures code is properly formatted
 * Auto-generated by Claude Autopilot
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        // Detect project type and check formatting
        const projectRoot = process.cwd();
        let formatCheckExecuted = false;
        
        // Node.js / JavaScript / TypeScript
        const packageJsonPath = path.join(projectRoot, 'package.json');
        if (fs.existsSync(packageJsonPath)) {
            try {
                const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                
                // Check for lint/format scripts
                if (pkg.scripts) {
                    if (pkg.scripts.lint) {
                        try {
                            console.error('Running npm lint...');
                            execSync('npm run lint', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            formatCheckExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.stdout || error.message;
                            errors.push(\`Linting failed: \${errorOutput}\`);
                            formatCheckExecuted = true;
                        }
                    } else if (pkg.scripts.format && pkg.scripts['format:check']) {
                        // Some projects have separate format:check script
                        try {
                            console.error('Running format check...');
                            execSync('npm run format:check', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            formatCheckExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.stdout || error.message;
                            errors.push(\`Format check failed: \${errorOutput}\`);
                            formatCheckExecuted = true;
                        }
                    }
                }
                
                // If no scripts, check for tools directly
                if (!formatCheckExecuted) {
                    // Prettier
                    const hasPrettier = pkg.devDependencies?.prettier || pkg.dependencies?.prettier;
                    if (hasPrettier || fs.existsSync(path.join(projectRoot, '.prettierrc')) || 
                        fs.existsSync(path.join(projectRoot, '.prettierrc.json')) ||
                        fs.existsSync(path.join(projectRoot, '.prettierrc.js')) ||
                        fs.existsSync(path.join(projectRoot, 'prettier.config.js'))) {
                        try {
                            console.error('Running Prettier check...');
                            execSync('npx prettier --check .', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            formatCheckExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.stdout || error.message;
                            if (errorOutput.includes('files were not formatted')) {
                                const unformattedFiles = errorOutput.match(/\\[warn\\] (.+)/g) || [];
                                errors.push(\`Prettier: \${unformattedFiles.length} file(s) not formatted\`);
                                unformattedFiles.slice(0, 10).forEach(file => {
                                    errors.push(file.replace('[warn] ', '  - '));
                                });
                                if (unformattedFiles.length > 10) {
                                    errors.push(\`  ... and \${unformattedFiles.length - 10} more files\`);
                                }
                            } else {
                                errors.push(\`Prettier check failed: \${errorOutput}\`);
                            }
                            formatCheckExecuted = true;
                        }
                    }
                    
                    // ESLint
                    const hasEslint = pkg.devDependencies?.eslint || pkg.dependencies?.eslint;
                    if (!formatCheckExecuted && (hasEslint || fs.existsSync(path.join(projectRoot, '.eslintrc')) ||
                        fs.existsSync(path.join(projectRoot, '.eslintrc.json')) ||
                        fs.existsSync(path.join(projectRoot, '.eslintrc.js')))) {
                        try {
                            console.error('Running ESLint...');
                            execSync('npx eslint .', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            formatCheckExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.stdout || error.message;
                            errors.push(\`ESLint found issues: \${errorOutput}\`);
                            formatCheckExecuted = true;
                        }
                    }
                    
                    // StandardJS
                    const hasStandard = pkg.devDependencies?.standard || pkg.dependencies?.standard;
                    if (!formatCheckExecuted && hasStandard) {
                        try {
                            console.error('Running StandardJS...');
                            execSync('npx standard', { 
                                stdio: ['ignore', 'ignore', 'pipe'],
                                encoding: 'utf8'
                            });
                            formatCheckExecuted = true;
                        } catch (error) {
                            const errorOutput = error.stderr || error.stdout || error.message;
                            errors.push(\`StandardJS found issues: \${errorOutput}\`);
                            formatCheckExecuted = true;
                        }
                    }
                }
                
                if (!formatCheckExecuted && (pkg.devDependencies || pkg.dependencies)) {
                    const deps = { ...pkg.devDependencies, ...pkg.dependencies };
                    if (deps.eslint || deps.prettier || deps.standard || deps.tslint) {
                        warnings.push('Formatting tools found in dependencies but no lint/format script configured');
                    }
                }
            } catch (error) {
                warnings.push(\`Could not parse package.json: \${error.message}\`);
            }
        }
        
        // Go
        if (!formatCheckExecuted && fs.existsSync(path.join(projectRoot, 'go.mod'))) {
            try {
                console.error('Running gofmt check...');
                const output = execSync('gofmt -l .', { encoding: 'utf8' });
                
                if (output.trim()) {
                    const files = output.trim().split('\\n');
                    errors.push(\`gofmt: \${files.length} file(s) not formatted:\`);
                    files.slice(0, 10).forEach(file => {
                        errors.push(\`  - \${file}\`);
                    });
                    if (files.length > 10) {
                        errors.push(\`  ... and \${files.length - 10} more files\`);
                    }
                } else {
                    formatCheckExecuted = true;
                }
            } catch (error) {
                warnings.push(\`gofmt check failed: \${error.message}\`);
            }
            
            // Also check go vet
            if (!errors.length) {
                try {
                    console.error('Running go vet...');
                    execSync('go vet ./...', { 
                        stdio: ['ignore', 'ignore', 'pipe'],
                        encoding: 'utf8'
                    });
                } catch (error) {
                    const errorOutput = error.stderr || error.message;
                    warnings.push(\`go vet found issues: \${errorOutput}\`);
                }
            }
            formatCheckExecuted = true;
        }
        
        // Rust
        if (!formatCheckExecuted && fs.existsSync(path.join(projectRoot, 'Cargo.toml'))) {
            try {
                console.error('Running rustfmt check...');
                execSync('cargo fmt -- --check', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                formatCheckExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                if (errorOutput.includes('Diff in')) {
                    errors.push('rustfmt: Some files need formatting. Run "cargo fmt" to fix.');
                } else {
                    errors.push(\`rustfmt check failed: \${errorOutput}\`);
                }
                formatCheckExecuted = true;
            }
            
            // Also run clippy if available
            try {
                console.error('Running clippy...');
                execSync('cargo clippy -- -D warnings', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
            } catch (error) {
                warnings.push('Clippy found warnings or is not installed');
            }
        }
        
        // Python
        if (!formatCheckExecuted && (fs.existsSync(path.join(projectRoot, 'setup.py')) || 
                                     fs.existsSync(path.join(projectRoot, 'pyproject.toml')) ||
                                     fs.existsSync(path.join(projectRoot, 'requirements.txt')))) {
            // Black
            try {
                console.error('Running black check...');
                execSync('python -m black --check .', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                formatCheckExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.stdout || error.message;
                if (errorOutput.includes('would be reformatted') || errorOutput.includes('would reformat')) {
                    const match = errorOutput.match(/(\\d+) file/);
                    const fileCount = match ? match[1] : 'Some';
                    errors.push(\`Black: \${fileCount} file(s) would be reformatted\`);
                    formatCheckExecuted = true;
                } else if (!errorOutput.includes('command not found') && !errorOutput.includes('No module named')) {
                    errors.push(\`Black check failed: \${errorOutput}\`);
                    formatCheckExecuted = true;
                }
            }
            
            // Flake8
            if (!formatCheckExecuted) {
                try {
                    console.error('Running flake8...');
                    execSync('python -m flake8 .', { 
                        stdio: ['ignore', 'ignore', 'pipe'],
                        encoding: 'utf8'
                    });
                    formatCheckExecuted = true;
                } catch (error) {
                    const errorOutput = error.stderr || error.stdout || error.message;
                    if (!errorOutput.includes('command not found') && !errorOutput.includes('No module named')) {
                        errors.push(\`Flake8 found issues: \${errorOutput}\`);
                        formatCheckExecuted = true;
                    }
                }
            }
            
            // Pylint
            if (!formatCheckExecuted) {
                try {
                    console.error('Running pylint...');
                    execSync('python -m pylint **/*.py', { 
                        stdio: ['ignore', 'ignore', 'pipe'],
                        encoding: 'utf8',
                        shell: true
                    });
                    formatCheckExecuted = true;
                } catch (error) {
                    const errorOutput = error.stderr || error.stdout || error.message;
                    if (!errorOutput.includes('command not found') && !errorOutput.includes('No module named')) {
                        warnings.push('Pylint found issues or is not configured');
                        formatCheckExecuted = true;
                    }
                }
            }
            
            if (!formatCheckExecuted) {
                warnings.push('Python project detected but no formatter (black/flake8/pylint) available');
            }
        }
        
        // C# / .NET
        if (!formatCheckExecuted && (fs.readdirSync(projectRoot).some(f => f.endsWith('.csproj')))) {
            try {
                console.error('Running dotnet format check...');
                execSync('dotnet format --verify-no-changes', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                formatCheckExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.message;
                if (errorOutput.includes('code changes were made')) {
                    errors.push('dotnet format: Code formatting changes needed');
                } else {
                    warnings.push('dotnet format not available or project not formatted');
                }
                formatCheckExecuted = true;
            }
        }
        
        // Java - Checkstyle/Spotless
        if (!formatCheckExecuted && fs.existsSync(path.join(projectRoot, 'pom.xml'))) {
            // Check if spotless is configured
            try {
                const pomContent = fs.readFileSync(path.join(projectRoot, 'pom.xml'), 'utf8');
                if (pomContent.includes('spotless-maven-plugin')) {
                    try {
                        console.error('Running spotless check...');
                        execSync('mvn spotless:check', { 
                            stdio: ['ignore', 'ignore', 'pipe'],
                            encoding: 'utf8'
                        });
                        formatCheckExecuted = true;
                    } catch (error) {
                        errors.push('Spotless: Code formatting changes needed. Run "mvn spotless:apply" to fix.');
                        formatCheckExecuted = true;
                    }
                }
            } catch (error) {
                // Ignore
            }
        }
        
        // Ruby - RuboCop
        if (!formatCheckExecuted && fs.existsSync(path.join(projectRoot, 'Gemfile'))) {
            try {
                console.error('Running RuboCop...');
                execSync('bundle exec rubocop', { 
                    stdio: ['ignore', 'ignore', 'pipe'],
                    encoding: 'utf8'
                });
                formatCheckExecuted = true;
            } catch (error) {
                const errorOutput = error.stderr || error.stdout || error.message;
                if (errorOutput.includes('offenses detected')) {
                    errors.push('RuboCop: Style violations detected');
                    formatCheckExecuted = true;
                }
            }
        }
        
        if (!formatCheckExecuted) {
            warnings.push('No recognized code formatter found. Supported: prettier, eslint, standard, gofmt, rustfmt, black, flake8, dotnet format, spotless, rubocop');
        }
        
        return {
            passed: errors.length === 0,
            errors,
            warnings
        };
    } catch (error) {
        return {
            passed: false,
            errors: [\`Script execution failed: \${error.message}\`],
            warnings
        };
    }
}

// Run the check and output results
check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [\`Unexpected error: \${error.message}\`]
    }, null, 2));
    process.exit(1);
});`,

    'github-actions.js': `#!/usr/bin/env node
/**
 * GitHub Actions Check
 * Validates GitHub Actions workflows
 * Auto-generated by Claude Autopilot
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

async function check() {
    const errors = [];
    const warnings = [];
    
    try {
        const projectRoot = process.cwd();
        const workflowsDir = path.join(projectRoot, '.github', 'workflows');
        
        if (!fs.existsSync(workflowsDir)) {
            warnings.push('No GitHub Actions workflows found (.github/workflows directory missing)');
            return {
                passed: true,
                errors,
                warnings
            };
        }
        
        // Get all workflow files
        const workflowFiles = fs.readdirSync(workflowsDir).filter(f => 
            f.endsWith('.yml') || f.endsWith('.yaml')
        );
        
        if (workflowFiles.length === 0) {
            warnings.push('No workflow files found in .github/workflows');
            return {
                passed: true,
                errors,
                warnings
            };
        }
        
        console.error(\`Found \${workflowFiles.length} workflow file(s)\`);
        
        // Check each workflow file
        for (const workflowFile of workflowFiles) {
            const workflowPath = path.join(workflowsDir, workflowFile);
            console.error(\`Checking \${workflowFile}...\`);
            
            try {
                const content = fs.readFileSync(workflowPath, 'utf8');
                
                // Basic structure validation
                if (content.trim() === '') {
                    errors.push(\`\${workflowFile}: Empty workflow file\`);
                    continue;
                }
                
                // Check for required top-level keys
                if (!content.includes('name:')) {
                    warnings.push(\`\${workflowFile}: Missing 'name' field (recommended for clarity)\`);
                }
                
                if (!content.includes('on:')) {
                    errors.push(\`\${workflowFile}: Missing 'on' trigger - workflow will never run\`);
                }
                
                if (!content.includes('jobs:')) {
                    errors.push(\`\${workflowFile}: Missing 'jobs' section - no jobs defined\`);
                }
                
                // Check for common syntax errors
                const lines = content.split('\\n');
                let inString = false;
                let indentStack = [0];
                
                lines.forEach((line, index) => {
                    const lineNum = index + 1;
                    const trimmedLine = line.trim();
                    
                    // Skip empty lines and comments
                    if (!trimmedLine || trimmedLine.startsWith('#')) return;
                    
                    // Check for tabs (YAML requires spaces)
                    if (line.includes('\\t')) {
                        errors.push(\`\${workflowFile}:\${lineNum} - Contains tabs (YAML requires spaces)\`);
                    }
                    
                    // Check for trailing whitespace
                    if (line !== line.trimEnd()) {
                        warnings.push(\`\${workflowFile}:\${lineNum} - Trailing whitespace\`);
                    }
                    
                    // Basic string detection for quotes
                    const quotes = (line.match(/['"]/g) || []).length;
                    if (quotes % 2 !== 0) {
                        inString = !inString;
                    }
                });
                
                // Check for deprecated actions
                const deprecatedActions = [
                    { pattern: /actions\\/setup-node@v1/g, replacement: 'actions/setup-node@v4' },
                    { pattern: /actions\\/checkout@v1/g, replacement: 'actions/checkout@v4' },
                    { pattern: /actions\\/checkout@v2/g, replacement: 'actions/checkout@v4' },
                    { pattern: /actions\\/setup-node@v2/g, replacement: 'actions/setup-node@v4' },
                    { pattern: /actions\\/cache@v1/g, replacement: 'actions/cache@v3' },
                    { pattern: /actions\\/upload-artifact@v1/g, replacement: 'actions/upload-artifact@v3' },
                    { pattern: /actions\\/download-artifact@v1/g, replacement: 'actions/download-artifact@v3' },
                    { pattern: /actions\\/create-release@v1/g, replacement: 'Use GitHub CLI (gh) instead' },
                    { pattern: /actions\\/upload-release-asset@v1/g, replacement: 'Use GitHub CLI (gh) instead' }
                ];
                
                deprecatedActions.forEach(({ pattern, replacement }) => {
                    if (pattern.test(content)) {
                        const matches = content.match(pattern);
                        const actionName = matches[0];
                        warnings.push(\`\${workflowFile}: Deprecated action '\${actionName}' - use '\${replacement}'\`);
                    }
                });
                
                // Check for insecure patterns
                if (content.includes('\${{ github.event.pull_request.title }}') || 
                    content.includes('\${{ github.event.pull_request.body }}') ||
                    content.includes('\${{ github.event.issue.title }}') ||
                    content.includes('\${{ github.event.issue.body }}')) {
                    warnings.push(\`\${workflowFile}: Potentially unsafe user input in workflow - could lead to script injection\`);
                }
                
                // Check for missing permissions
                if (content.includes('GITHUB_TOKEN') && !content.includes('permissions:')) {
                    warnings.push(\`\${workflowFile}: Uses GITHUB_TOKEN but no 'permissions' specified - using default permissions\`);
                }
                
                // Try actionlint if available
                try {
                    execSync(\`actionlint \${workflowPath}\`, { 
                        stdio: ['ignore', 'ignore', 'pipe'],
                        encoding: 'utf8'
                    });
                } catch (error) {
                    const errorOutput = error.stderr || error.stdout || '';
                    
                    if (errorOutput.includes('command not found') || errorOutput.includes('not recognized')) {
                        // actionlint not installed - try basic YAML validation
                        try {
                            // Try to parse YAML with Node.js
                            execSync(\`node -e "const yaml = require('js-yaml'); yaml.load(require('fs').readFileSync('\${workflowPath}', 'utf8'));"\`, {
                                stdio: 'ignore'
                            });
                        } catch (yamlError) {
                            errors.push(\`\${workflowFile}: Invalid YAML syntax\`);
                        }
                        
                        // If no js-yaml, skip YAML validation
                        warnings.push('Install actionlint for comprehensive workflow validation');
                    } else if (errorOutput) {
                        // actionlint found issues
                        const actionlintErrors = errorOutput.split('\\n').filter(line => line.trim());
                        actionlintErrors.forEach(error => {
                            if (error.includes(workflowPath)) {
                                // Extract just the relevant part after the filename
                                const errorMessage = error.split(workflowPath)[1] || error;
                                errors.push(\`\${workflowFile}\${errorMessage}\`);
                            } else if (!error.includes('actionlint: not found')) {
                                errors.push(\`\${workflowFile}: \${error}\`);
                            }
                        });
                    }
                }
                
                // Check for workflow-specific issues
                
                // Check if workflow uses matrix but doesn't define it
                if (content.includes('\${{ matrix.') && !content.includes('matrix:')) {
                    errors.push(\`\${workflowFile}: References matrix variables but no matrix strategy defined\`);
                }
                
                // Check for common job issues
                const jobMatches = content.match(/^\\s{2}[\\w-]+:/gm) || [];
                if (jobMatches.length === 0 && content.includes('jobs:')) {
                    errors.push(\`\${workflowFile}: 'jobs' section exists but no jobs defined\`);
                }
                
                // Check for invalid cron syntax
                const cronMatches = content.match(/cron:\\s*['"]([^'"]+)['"]/g) || [];
                cronMatches.forEach(match => {
                    const cron = match.match(/['"]([^'"]+)['"]/)[1];
                    const cronParts = cron.split(' ');
                    if (cronParts.length !== 5) {
                        errors.push(\`\${workflowFile}: Invalid cron expression '\${cron}' - must have 5 fields\`);
                    }
                });
                
            } catch (error) {
                errors.push(\`\${workflowFile}: Failed to read or parse - \${error.message}\`);
            }
        }
        
        // Additional checks for workflow best practices
        const readmeExists = fs.existsSync(path.join(projectRoot, 'README.md'));
        if (readmeExists) {
            try {
                const readme = fs.readFileSync(path.join(projectRoot, 'README.md'), 'utf8');
                const hasBadges = workflowFiles.some(file => {
                    const workflowName = file.replace(/\\.(yml|yaml)$/, '');
                    return readme.includes(\`\${workflowName}/badge.svg\`) || 
                           readme.includes('actions/workflows/');
                });
                
                if (workflowFiles.length > 0 && !hasBadges) {
                    warnings.push('Consider adding GitHub Actions status badges to README.md');
                }
            } catch (error) {
                // Ignore README read errors
            }
        }
        
        return {
            passed: errors.length === 0,
            errors,
            warnings
        };
    } catch (error) {
        return {
            passed: false,
            errors: [\`Script execution failed: \${error.message}\`],
            warnings
        };
    }
}

// Run the check and output results
check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [\`Unexpected error: \${error.message}\`]
    }, null, 2));
    process.exit(1);
});`
};

export const DEFAULT_CONFIG = {
    scripts: [
        {
            id: "production-readiness",
            name: "Production Readiness Check",
            description: "Checks for TODO, FIXME, placeholders, and incomplete implementations",
            enabled: true,
            order: 1
        },
        {
            id: "build-check",
            name: "Build Check",
            description: "Ensures the project can build successfully",
            enabled: true,
            order: 2
        },
        {
            id: "test-check",
            name: "Test Check",
            description: "Runs all tests and ensures they pass",
            enabled: true,
            order: 3
        },
        {
            id: "format-check",
            name: "Format Check",
            description: "Ensures code is properly formatted",
            enabled: true,
            order: 4
        },
        {
            id: "github-actions",
            name: "GitHub Actions Check",
            description: "Validates GitHub Actions workflows",
            enabled: true,
            order: 5
        }
    ],
    maxIterations: 5
};

export const SCRIPTS_README = `# Claude Autopilot Scripts

This folder contains quality check scripts that ensure your code meets production standards.

## Built-in Scripts

1. **production-readiness.js** - Scans for TODO, FIXME, placeholders, and incomplete implementations
2. **build-check.js** - Ensures the project builds successfully
3. **test-check.js** - Runs all tests and ensures they pass
4. **format-check.js** - Validates code formatting
5. **github-actions.js** - Checks GitHub Actions workflow syntax and best practices

## Custom Scripts

You can add your own validation scripts to this folder. Scripts must:

1. Be executable JavaScript files (\`.js\`)
2. Output JSON to stdout in this format:
\`\`\`json
{
  "passed": true/false,
  "errors": ["error1", "error2"],
  "warnings": ["warning1"] // optional
}
\`\`\`
3. Exit with code 0 if passed, 1 if failed

## Example Custom Script

\`\`\`javascript
#!/usr/bin/env node

async function check() {
    const errors = [];
    const warnings = [];
    
    // Your validation logic here
    if (someCondition) {
        errors.push("Found an issue");
    }
    
    return {
        passed: errors.length === 0,
        errors,
        warnings
    };
}

check().then(result => {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.passed ? 0 : 1);
}).catch(error => {
    console.error(JSON.stringify({
        passed: false,
        errors: [\`Unexpected error: \${error.message}\`]
    }, null, 2));
    process.exit(1);
});
\`\`\`

## Configuration

Scripts are configured in \`../.autopilot/config.json\`. You can:
- Enable/disable scripts
- Change execution order
- Set max iterations for fix loops

## Running Scripts

Scripts are run automatically by Claude Autopilot when you:
- Click "Run Checks" to validate once
- Click "Run Loop" to fix issues automatically
- Use the  button on messages for quality loops`;